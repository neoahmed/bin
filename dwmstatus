#!/bin/sh
# ~/.local/bin/dwmstatus
#

SEP=";"
INTERVAL=1   # update each second 

# Helpers
command_exists() { command -v "$1" >/dev/null 2>&1; }

get_volume() {
    if command_exists pactl; then
        sink="@DEFAULT_SINK@"
        vol=$(pactl get-sink-volume "$sink" | awk '{print $5}' | tr -d '%')
        mute=$(pactl get-sink-mute "$sink" | awk '{print $2}')
        if [ "$mute" = "yes" ]; then
            echo "Vol: MUTE"
        else
            echo "Vol: ${vol}%"
        fi
    elif command_exists amixer; then
        vol=$(amixer get Master 2>/dev/null | awk -F'[][]' '/%/ {print $2; exit}')
        mute=$(amixer get Master 2>/dev/null | grep '\[off\]' || true)
        if [ -n "$mute" ]; then
            echo "Vol: MUTE"
        else
            echo "Vol: ${vol%%%}"
        fi
    else
        echo "Vol: N/A"
    fi
}


# CPU load (1-min) and temp
get_cpu_and_temp() {
    # loadavg first field with 2 decimals
    load=$(awk '{printf "%.2f", $1}' /proc/loadavg)
    # temp from sensors (may vary by machine)
    if command_exists sensors; then
        temp=$(sensors 2>/dev/null | awk '/^Package id 0:/{gsub(/\+|Â°C/,"",$4); print $4; exit}')
        [ -z "$temp" ] && temp=$(sensors 2>/dev/null | awk '/^Core 0:/{gsub(/\+|Â°C/,"",$3); print $3; exit}')
    else
        temp=""
    fi
    if [ -n "$temp" ]; then
        echo "CPU: ${load} - ${temp}Â°C"
    else
        echo "CPU: ${load} - N/A"
    fi
}


get_datetime() {
    date '+%a %d %b - %H:%M'
}

get_battery() {
    # reads first battery found
    bat_path=$(ls /sys/class/power_supply/ 2>/dev/null | grep -E '^BAT' | head -n1)
    if [ -n "$bat_path" ]; then
        cap=$(cat /sys/class/power_supply/"$bat_path"/capacity 2>/dev/null)
        stat=$(cat /sys/class/power_supply/"$bat_path"/status 2>/dev/null)
        [ -n "$cap" ] && printf "%s%% %s" "$cap" "${stat:-}"
    else
        echo "Bat: N/A"
    fi
}


get_center() {
    pidfile="/tmp/screencast.pid"
    
    if [ -f "$pidfile" ]; then
        pid=$(cat "$pidfile" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            printf "ðŸ”´ REC"
            return
        fi
    fi

    if pgrep -x ffmpeg >/dev/null 2>&1; then
        printf "ðŸ”´ REC"
    else
        printf ""
    fi

}

# update function (will be callable by trap)
update() {
    center="$(get_center)"
    right="$(get_volume) | $(get_datetime) | $(get_cpu_and_temp) | $(get_battery)"
    xsetroot -name "${center} ${SEP} ${right}"
}

# trap USR1 to force immediate update
trap 'update' USR1

# initial update
update

# main loop â€” update periodically
while true; do
    sleep "$INTERVAL"
    update
done

